このシステムは、**タスクキュー**、**ワーカー**、**スケジューラ**という3つの主要コンポーネントで構成される、非同期タスク処理システムです。バックエンドにはRedisが使用されており、堅牢性とスケーラビリティを確保しています。

### アーキテクチャの概要図

```
(ユーザー/クライアント)
       |
       | 1. タスク投入 (Task Object)
       v
+----------------+      +----------------------+
| Task Scheduler |----->|      Task Queue      |<----- 3. タスク取得
| (Cron-based)   |      | (Redis-backed)       |       (Dequeue)
+----------------+      +----------------------+----------+
       ^                | - Priority Queues    |          |
       | 2. 定期実行.    | - State Management   |          |
       |                | - Dependency Graph   |          v
       |                | - XCom (Data Sharing)|   +-------------+
       |                +----------------------+   |   Worker    |
       |                                            | (Processor) |
       +--------------------------------------------+-------------+
                                                    | 4. タスク実行
                                                    | (Task Handler)
                                                    |
                                                    v 5. 結果通知
                                                    (Finish/Fail)
```

### 主要コンポーネント

1.  **`Task` (タスク)**
    *   **役割**: 実行されるべき仕事の単位です。(`fairque.core.models.Task`)
    *   **特徴**:
        *   `task_id`, `user_id`, `priority` (優先度), `payload` (データ) といった属性を持ちます。
        *   実行すべきPython関数 (`func`) とその引数 (`args`, `kwargs`) を直接カプセル化できます。これにより、関数をそのままタスクとして扱えます。
        *   `@task` デコレータ (`fairque.decorator.task`) を使うことで、通常のPython関数を簡単に `Task` オブジェクトに変換できます。
        *   タスク間の依存関係 (`depends_on`) を定義できます。

2.  **`TaskQueue` (タスクキュー)**
    *   **役割**: システムの中心となるメッセージキューです。(`fairque.queue.queue.TaskQueue`)
    *   **特徴**:
        *   **Redisベース**: 状態管理、キューイング、データ共有のすべてをRedis上で行います。
        *   **公平なスケジューリング**: `FairQueue` という名前の通り、タスクの投入時間と優先度を考慮したスコア計算 (`calculate_score`) を行い、特定のユーザーや高優先度のタスクがシステムを占有しすぎないように（飢餓状態を防ぐように）設計されています。ただし、最優先の `CRITICAL` タスクは別のFIFOキューで処理され、即時実行が試みられます。
        *   **堅牢な状態管理**: `TaskState` (`QUEUED`, `STARTED`, `FINISHED`, `FAILED`など) を通じて、タスクのライフサイクルを厳密に管理します。
        *   **Luaスクリプトの活用**: Redisに対する複雑な操作（タスクの取得と状態更新など）をLuaスクリプト (`push.lua`, `pop.lua`) としてRedisサーバー上でアトミックに実行します。これにより、アプリケーションとRedis間の通信回数を削減し、競合状態を防ぎ、高いパフォーマンスと一貫性を保証しています。
        *   **依存関係の解決**: あるタスクが完了した際に、そのタスクに依存していた別のタスクを自動的に実行可能状態 (`QUEUED`) に遷移させる機能を持っています。

3.  **`Worker` (ワーカー)**
    *   **役割**: `TaskQueue` からタスクを取得し、実際に処理を実行するプロセスです。(`fairque.worker.worker.Worker`)
    *   **特徴**:
        *   `TaskQueue` をポーリングして、実行可能なタスクを非同期に取得します。
        *   `ThreadPoolExecutor` を利用して、複数のタスクを並行して処理できます。
        *   `TaskHandler` という抽象クラスを実装することで、ユーザーは独自のタスク処理ロジックを定義できます。`FunctionTaskHandler` は、タスクに紐付けられたPython関数を実行するためのデフォルト実装です。
        *   タスクの実行が完了したら、`TaskQueue` に成功 (`finish_task`) または失敗 (`fail_task`) を通知します。

4.  **`TaskScheduler` (スケジューラ)**
    *   **役割**: Cron式に基づき、指定された日時にタスクを定期的に実行します。(`fairque.scheduler.scheduler.TaskScheduler`)
    *   **特徴**:
        *   Cronジョブのように「毎日午前9時にこのタスクを実行する」といったスケジューリングが可能です。
        *   分散ロック (`fairque:scheduler_lock`) を利用しており、複数のスケジューラが同時に起動していても、実際にタスクを処理するのは1つのインスタンスのみであることが保証されます。
        *   実行時刻になると、対応する `Task` を生成し、`TaskQueue` に投入します。

### 重要なコンセプト

*   **XCom (Cross-Communication)**: タスク間で少量のデータを共有するための仕組みです。例えば、あるタスクの実行結果を、後続のタスクが利用する、といったパイプライン処理を構築するのに役立ちます。`@xcom_push` や `@xcom_pull` デコレータで簡単に利用できます。
*   **設定駆動**: `config/` ディレクトリ内のYAMLファイルで、ワーカーの挙動やRedisの接続情報などを環境ごとに柔軟に設定できます。

### まとめ

このシステムは、Redisを単なるキューとしてだけでなく、**アトミックな操作が可能なステートマシン**として活用することで、公平性、依存関係の解決、定期実行といった高度な機能を実現する、スケーラブルで堅牢な分散タスクキューシステムです。
