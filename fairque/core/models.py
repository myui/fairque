"""Core models for FairQueue: Priority, Task, and DLQEntry."""

import dataclasses
import json
import logging
import os
import time
import uuid
from dataclasses import dataclass, field
from enum import IntEnum
from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple

from fairque.core.exceptions import TaskSerializationError

if TYPE_CHECKING:
    from fairque.core.xcom import XComManager

logger = logging.getLogger(__name__)


class Priority(IntEnum):
    """Task priority levels with type safety."""

    VERY_LOW = 1    # Lowest priority, minimal time weight
    LOW = 2         # Low priority
    NORMAL = 3      # Standard priority
    HIGH = 4        # High priority
    VERY_HIGH = 5   # Very high priority, maximum time weight
    CRITICAL = 6    # Critical priority, uses separate FIFO queue

    @property
    def weight(self) -> float:
        """Get priority weight for score calculation (1-5 only).

        Returns:
            Priority weight as float between 0.2 and 1.0

        Raises:
            ValueError: If called on CRITICAL priority
        """
        if self == Priority.CRITICAL:
            raise ValueError("Critical priority does not use weight calculation")
        return self.value / 5.0

    @property
    def is_critical(self) -> bool:
        """Check if priority is critical.

        Returns:
            True if priority is CRITICAL, False otherwise
        """
        return self == Priority.CRITICAL

    @classmethod
    def from_int(cls, value: int) -> "Priority":
        """Create Priority from integer with validation.

        Args:
            value: Integer value (1-6)

        Returns:
            Priority enum instance

        Raises:
            ValueError: If value is not in valid range
        """
        try:
            return cls(value)
        except ValueError:
            raise ValueError(f"Invalid priority value: {value}. Must be 1-6.") from None


def calculate_score(task: "Task") -> float:
    """Calculate priority score for normal queue ordering.

    Higher score = higher priority for processing.
    Formula: created_at + (priority_weight * elapsed_time)
    This prevents starvation while respecting priority levels.

    Args:
        task: Task to calculate score for

    Returns:
        Priority score as float

    Raises:
        ValueError: If task has CRITICAL priority
    """
    if task.priority.is_critical:
        raise ValueError("Critical tasks do not use score calculation")

    current_time = time.time()
    elapsed_time = current_time - task.created_at
    priority_weight = task.priority.weight

    return task.created_at + (priority_weight * elapsed_time)


@dataclass
class Task:
    """Optimized Task model with efficient serialization and function execution support."""

    task_id: str           # UUID4 auto-generated by system
    user_id: str
    priority: Priority     # Priority enum (1-6)
    payload: Dict[str, Any]
    retry_count: int = 0
    max_retries: int = 3
    created_at: float = field(default_factory=time.time)
    execute_after: float = field(default_factory=time.time)

    # Function execution support
    func: Optional[Callable[..., Any]] = field(default=None, compare=False, repr=False)
    args: Tuple[Any, ...] = field(default_factory=tuple, compare=False, repr=False)
    kwargs: Dict[str, Any] = field(default_factory=dict, compare=False, repr=False)

    # XCom configuration
    enable_xcom: bool = False
    xcom_push_key: Optional[str] = None
    xcom_pull_keys: Dict[str, str] = field(default_factory=dict)
    xcom_ttl_seconds: int = 3600
    xcom_namespace: str = "default"  # Default namespace

    # XCom manager reference (injected by TaskHandler)
    _xcom_manager: Optional['XComManager'] = field(default=None, init=False, repr=False, compare=False)

    @classmethod
    def create(
        cls,
        user_id: Optional[str] = None,
        priority: Priority = Priority.NORMAL,
        payload: Dict[str, Any] = {},   # noqa: B006
        max_retries: int = 3,
        execute_after: Optional[float] = None,
        func: Optional[Callable[..., Any]] = None,
        args: Tuple[Any, ...] = (),
        kwargs: Dict[str, Any] = {},  # noqa: B006
        auto_xcom: bool = True,
        # XCom parameters
        enable_xcom: bool = False,
        xcom_namespace: str = "default",
        xcom_ttl_seconds: int = 3600,
    ) -> "Task":
        """Create new task with auto-generated UUID and XCom support.

        Args:
            user_id: User identifier (default: from environment USER)
            priority: Task priority
            payload: Task data payload
            max_retries: Maximum retry attempts
            execute_after: Timestamp when task should be executed (defaults to now)
            func: Optional function to execute
            args: Function arguments
            kwargs: Function keyword arguments
            auto_xcom: Automatically configure XCom from function decorators
            enable_xcom: Enable XCom functionality
            xcom_namespace: XCom namespace for data storage
            xcom_ttl_seconds: Default TTL for XCom data

        Returns:
            New Task instance
        """
        if user_id is None:
            user_id = os.environ.get("USER", "unknown")
            assert user_id, "User ID must be provided or set in environment"

        current_time = time.time()
        task = cls(
            task_id=str(uuid.uuid4()),
            user_id=user_id,
            priority=priority,
            payload=payload,
            retry_count=0,
            max_retries=max_retries,
            created_at=current_time,
            execute_after=execute_after or current_time,
            func=func,
            args=args,
            kwargs=kwargs,
            enable_xcom=enable_xcom,
            xcom_namespace=xcom_namespace,
            xcom_ttl_seconds=xcom_ttl_seconds,
        )

        # Auto-configure XCom from function decorators
        if auto_xcom and func:
            task._configure_xcom_from_decorators()

        return task

    def is_ready_to_execute(self) -> bool:
        """Check if task is ready to execute based on execute_after timestamp.

        Returns:
            True if task is ready to execute, False otherwise
        """
        return time.time() >= self.execute_after

    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        """Make Task callable. Execute the stored function or update arguments.

        Args:
            *args: Positional arguments for function execution or argument update
            **kwargs: Keyword arguments for function execution or argument update

        Returns:
            Function result if no arguments provided, or new Task instance with updated arguments

        Raises:
            ValueError: If no function is set and no arguments provided
        """
        if args or kwargs:
            # Update arguments and return new Task instance
            new_args = args if args else self.args
            new_kwargs = {**self.kwargs, **kwargs} if kwargs else self.kwargs
            return dataclasses.replace(self, args=new_args, kwargs=new_kwargs)
        else:
            # Execute the function
            return self.call_function()

    def call_function(self) -> Any:
        """Execute the stored function with arguments.

        Returns:
            Function execution result

        Raises:
            ValueError: If no function is set for this task
        """
        if self.func is None:
            raise ValueError("No function set for this task")
        return self.func(*self.args, **self.kwargs)

    def can_retry(self) -> bool:
        """Check if task can be retried.

        Returns:
            True if retry count is below max_retries, False otherwise
        """
        return self.retry_count < self.max_retries

    def get_retry_delay(self) -> float:
        """Calculate exponential backoff delay for retry.

        Returns:
            Delay in seconds for next retry attempt
        """
        return 2.0 ** self.retry_count

    def increment_retry(self) -> "Task":
        """Return new task instance with incremented retry count and updated execute_after.

        Returns:
            New Task instance with incremented retry count
        """
        delay = self.get_retry_delay()
        return dataclasses.replace(
            self,
            retry_count=self.retry_count + 1,
            execute_after=time.time() + delay,
        )

    # XCom methods
    def set_xcom_manager(self, xcom_manager: 'XComManager') -> None:
        """Set XCom manager reference (called by TaskHandler)."""
        self._xcom_manager = xcom_manager

    def xcom_push(self, key: str, value: Any, ttl_seconds: Optional[int] = None, namespace: Optional[str] = None) -> None:
        """Push value to XCom with namespace.

        Args:
            key: XCom key name
            value: Value to store
            ttl_seconds: TTL override (if None, use task's xcom_ttl_seconds)
            namespace: Namespace override (if None, use task's xcom_namespace)

        Raises:
            RuntimeError: If XCom is not enabled for this task
        """
        if not self.enable_xcom:
            raise RuntimeError("XCom is not enabled for this task. Set enable_xcom=True.")

        if not self._xcom_manager:
            raise RuntimeError("XCom manager not available. Task must be processed by XCom-enabled TaskHandler.")

        effective_ttl = ttl_seconds if ttl_seconds is not None else self.xcom_ttl_seconds
        effective_namespace = namespace if namespace is not None else self.xcom_namespace

        self._xcom_manager.push(
            key=key,
            value=value,
            user_id=self.user_id,
            namespace=effective_namespace,
            ttl_seconds=effective_ttl
        )

        ttl_info = "no TTL" if effective_ttl == 0 else f"TTL {effective_ttl}s"
        logger.debug(f"XCom pushed: key={key}, namespace={effective_namespace}, {ttl_info}")

    def xcom_pull(self, key: str, default: Any = None, namespace: Optional[str] = None) -> Any:
        """Pull value from XCom by key and namespace.

        Args:
            key: XCom key name
            default: Default value if key not found
            namespace: Specific namespace (if None, use task's namespace)

        Returns:
            Value from XCom or default

        Raises:
            RuntimeError: If XCom is not enabled for this task
        """
        if not self.enable_xcom:
            raise RuntimeError("XCom is not enabled for this task. Set enable_xcom=True.")

        if not self._xcom_manager:
            raise RuntimeError("XCom manager not available. Task must be processed by XCom-enabled TaskHandler.")

        effective_namespace = namespace if namespace is not None else self.xcom_namespace

        try:
            return self._xcom_manager.pull(key=key, user_id=self.user_id, namespace=effective_namespace)
        except KeyError:
            if default is not None:
                return default
            raise

    def xcom_pull_from_namespace(self, namespace: Optional[str] = None) -> Dict[str, Any]:
        """Pull all keys from a namespace.

        Args:
            namespace: Target namespace (if None, use task's namespace)

        Returns:
            Dictionary mapping keys to values

        Raises:
            RuntimeError: If XCom is not enabled for this task
        """
        if not self.enable_xcom:
            raise RuntimeError("XCom is not enabled for this task. Set enable_xcom=True.")

        if not self._xcom_manager:
            raise RuntimeError("XCom manager not available. Task must be processed by XCom-enabled TaskHandler.")

        effective_namespace = namespace if namespace is not None else self.xcom_namespace
        return self._xcom_manager.pull_from_namespace(effective_namespace, self.user_id)

    def xcom_clear_namespace(self, namespace: Optional[str] = None) -> int:
        """Clear all XCom data in a namespace.

        Args:
            namespace: Target namespace (if None, use task's namespace)

        Returns:
            Number of entries cleared

        Raises:
            RuntimeError: If XCom is not enabled for this task
        """
        if not self.enable_xcom:
            raise RuntimeError("XCom is not enabled for this task. Set enable_xcom=True.")

        if not self._xcom_manager:
            raise RuntimeError("XCom manager not available. Task must be processed by XCom-enabled TaskHandler.")

        effective_namespace = namespace if namespace is not None else self.xcom_namespace
        return self._xcom_manager.cleanup_namespace(effective_namespace, self.user_id, "manual_clear")

    def _configure_xcom_from_decorators(self) -> None:
        """Configure XCom settings from function decorators."""
        if not self.func:
            return

        # Check for xcom_task decorator (highest priority)
        config = getattr(self.func, '_xcom_task_config', None)
        if config is not None:
            self.enable_xcom = True
            self.xcom_push_key = config.get('push_key')
            self.xcom_pull_keys = config.get('pull_keys', {})
            self.xcom_ttl_seconds = config.get('ttl_seconds', 3600)
            # Use decorator namespace or keep task's namespace
            if config.get('namespace'):
                self.xcom_namespace = config['namespace']
            logger.debug(f"Configured XCom from @xcom_task decorator: {self.task_id}, namespace={self.xcom_namespace}")
            return

        # Check for individual decorators
        has_xcom_config = False

        config = getattr(self.func, '_xcom_push_config', None)
        if config is not None:
            self.enable_xcom = True
            self.xcom_push_key = config.get('key')
            self.xcom_ttl_seconds = config.get('ttl_seconds', 3600)
            if config.get('namespace'):
                self.xcom_namespace = config['namespace']
            has_xcom_config = True

        config = getattr(self.func, '_xcom_pull_config', None)
        if config is not None:
            self.enable_xcom = True
            self.xcom_pull_keys.update(config.get('keys', {}))
            if config.get('namespace'):
                self.xcom_namespace = config['namespace']
            has_xcom_config = True

        if has_xcom_config:
            logger.debug(f"Configured XCom from decorators: {self.task_id}, namespace={self.xcom_namespace}")

    # Optimized serialization methods
    def to_redis_dict(self) -> Dict[str, str]:
        """Redis storage with function metadata embedded in payload."""
        base_data = {
            "task_id": self.task_id,
            "user_id": self.user_id,
            "priority": str(self.priority.value),  # int as string
            "retry_count": str(self.retry_count),
            "max_retries": str(self.max_retries),
            "created_at": f"{self.created_at:.6f}",  # limited precision
            "execute_after": f"{self.execute_after:.6f}",
        }

        # Embed function metadata in payload
        if self.func is not None:
            from fairque.core.function_registry import serialize_function
            func_meta = serialize_function(self.func)
            enhanced_payload = {
                **self.payload,
                "__function_meta__": func_meta,
                "__function_args__": list(self.args),  # Convert tuple to list for JSON
                "__function_kwargs__": self.kwargs,
                "__is_function_task__": True
            }
            base_data["payload"] = json.dumps(enhanced_payload, separators=(",", ":"))
        else:
            base_data["payload"] = json.dumps(self.payload, separators=(",", ":"))  # minimal JSON

        return base_data

    @classmethod
    def from_redis_dict(cls, data: Dict[str, str]) -> "Task":
        """Restore from Redis with function fallback resolution.

        Args:
            data: Dictionary from Redis with string keys and values

        Returns:
            Task instance restored from Redis data

        Raises:
            TaskSerializationError: If deserialization fails
        """
        payload = json.loads(data["payload"])

        # Create base task instance
        task = cls(
            task_id=data["task_id"],
            user_id=data["user_id"],
            priority=Priority(int(data["priority"])),
            payload={k: v for k, v in payload.items()
                    if not k.startswith("__function")},
            retry_count=int(data["retry_count"]),
            max_retries=int(data["max_retries"]),
            created_at=float(data["created_at"]),
            execute_after=float(data["execute_after"]),
        )

        # Restore function if present
        if payload.get("__is_function_task__"):
            func_meta = payload.get("__function_meta__")
            if func_meta:
                from fairque.core.function_registry import try_deserialize_function
                func, strategy = try_deserialize_function(func_meta)
                if func is not None:
                    task.func = func
                    task.args = tuple(payload.get("__function_args__", []))
                    task.kwargs = payload.get("__function_kwargs__", {})
                    logger.debug(f"Function restored using {strategy}: {func_meta}")
                else:
                    logger.warning(f"Failed to restore function: {func_meta}")
                    # Function task without function - will be handled in TaskHandler

        return task

    def to_lua_args(self) -> List[str]:
        """Lua script argument list (optimized for array transmission).

        Returns:
            List of string arguments for Lua script
        """
        redis_dict = self.to_redis_dict()
        return [
            redis_dict["task_id"],
            redis_dict["user_id"],
            redis_dict["priority"],
            redis_dict["payload"],
            redis_dict["retry_count"],
            redis_dict["max_retries"],
            redis_dict["created_at"],
            redis_dict["execute_after"],
        ]

    @classmethod
    def from_lua_result(cls, lua_args: List[str]) -> "Task":
        """Restore from Lua script result (optimized array format).

        Args:
            lua_args: List of string arguments from Lua script

        Returns:
            Task instance restored from Lua result

        Raises:
            TaskSerializationError: If deserialization fails
        """
        if len(lua_args) != 8:
            raise TaskSerializationError(
                f"Invalid lua_args length: expected 8, got {len(lua_args)}"
            )

        return cls(
            task_id=lua_args[0],
            user_id=lua_args[1],
            priority=Priority(int(lua_args[2])),
            payload=json.loads(lua_args[3]),
            retry_count=int(lua_args[4]),
            max_retries=int(lua_args[5]),
            created_at=float(lua_args[6]),
            execute_after=float(lua_args[7]),
        )


@dataclass
class DLQEntry:
    """Simplified DLQ entry with failure type embedded."""

    entry_id: str           # UUID4 for DLQ entry
    original_task: Task     # Failed original task
    failure_type: str       # "failed"|"expired"|"poisoned"
    reason: str            # Failure reason description
    moved_at: float        # Timestamp when moved to DLQ
    retry_history: List[Dict[str, Any]] = field(default_factory=list)

    @classmethod
    def create(cls, task: Task, failure_type: str, reason: str) -> "DLQEntry":
        """Create new DLQ entry.

        Args:
            task: Original failed task
            failure_type: Type of failure ("failed", "expired", "poisoned")
            reason: Human-readable failure reason

        Returns:
            New DLQEntry instance
        """
        return cls(
            entry_id=str(uuid.uuid4()),
            original_task=task,
            failure_type=failure_type,
            reason=reason,
            moved_at=time.time(),
            retry_history=[],
        )

    def get_age_seconds(self) -> float:
        """Get age of this DLQ entry in seconds.

        Returns:
            Age in seconds since entry was moved to DLQ
        """
        return time.time() - self.moved_at
